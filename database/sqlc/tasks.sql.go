// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: tasks.sql

package goAPI

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const endTask = `-- name: EndTask :one
update tasks
set end_time = now()
where people_id = $1
  and end_time is null
returning id, people_id, name, start_time, end_time
`

func (q *Queries) EndTask(ctx context.Context, peopleID uuid.UUID) (Task, error) {
	row := q.db.QueryRow(ctx, endTask, peopleID)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.PeopleID,
		&i.Name,
		&i.StartTime,
		&i.EndTime,
	)
	return i, err
}

const getTasksByPeople = `-- name: GetTasksByPeople :many
select name,
       (extract(epoch from coalesce(end_time, now()) - start_time) / 3600)::integer   as hours,
       (extract(epoch from coalesce(end_time, now()) - start_time) / 60 % 60)::integer as minutes
from tasks
where people_id = $1
  and (
    ($2::timestamptz is null and $3::timestamptz is null)
        or tstzrange(
                   coalesce(cast($2 as timestamptz), '-infinity'::timestamptz),
                   coalesce(cast($3 as timestamptz), 'infinity'::timestamptz), '[]'
           ) @> tstzrange(start_time, coalesce(end_time, 'infinity'::timestamptz), '[]')
    )
order by (coalesce(end_time, now()) - start_time) desc
`

type GetTasksByPeopleParams struct {
	PeopleID    uuid.UUID  `json:"peopleId"`
	PeriodStart *time.Time `json:"periodStart"`
	PeriodEnd   *time.Time `json:"periodEnd"`
}

type GetTasksByPeopleRow struct {
	Name    string `example:"Помыть посуду" json:"name"`
	Hours   int32  `json:"hours"`
	Minutes int32  `json:"minutes"`
}

func (q *Queries) GetTasksByPeople(ctx context.Context, arg GetTasksByPeopleParams) ([]GetTasksByPeopleRow, error) {
	rows, err := q.db.Query(ctx, getTasksByPeople, arg.PeopleID, arg.PeriodStart, arg.PeriodEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTasksByPeopleRow
	for rows.Next() {
		var i GetTasksByPeopleRow
		if err := rows.Scan(&i.Name, &i.Hours, &i.Minutes); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const startTask = `-- name: StartTask :one
insert into tasks
    (people_id, name)
values ($1, $2)
returning id, people_id, name, start_time, end_time
`

type StartTaskParams struct {
	PeopleID uuid.UUID `json:"peopleId"`
	Name     string    `example:"Помыть посуду" json:"name"`
}

func (q *Queries) StartTask(ctx context.Context, arg StartTaskParams) (Task, error) {
	row := q.db.QueryRow(ctx, startTask, arg.PeopleID, arg.Name)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.PeopleID,
		&i.Name,
		&i.StartTime,
		&i.EndTime,
	)
	return i, err
}
